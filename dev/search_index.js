var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = GeometricTheoremProver","category":"page"},{"location":"api/#GeometricTheoremProver","page":"API","title":"GeometricTheoremProver","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for GeometricTheoremProver.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GeometricTheoremProver]","category":"page"},{"location":"api/#GeometricTheoremProver.prove-Tuple{GeometricTheoremProver.Hypothesis, GeometricTheoremProver.Thesis}","page":"API","title":"GeometricTheoremProver.prove","text":"prove(hp::Hypothesis, th::Thesis[, method=RittWuMethod])\nprove(theorem::Theorem[, method=RittWuMethod])\n\nProves a thereom with given hypothesis hp and thesis th.\n\nInput\n\nhp::Hypothesis                  – hypothesis of the theorem\nth::Thesis                      – thesis of the theorem\nmethod<:AbstractGeometricProver – method to prove the theorem, default RittWuMethod.\n\nAlternatively, instead of passing hypothesis and thesis as two distinct parameters, it is possible to pass them together as a Theorem object.\n\nOutput\n\nA proof of the the theorem. The type of the output depends on the chosen method\n\nAlgorithms\n\nCurrently the following provers are supported\n\nRittWuMethod\n\nExamples\n\njulia> hp = @hp D := Parallelogram(A, B, C, D)\nPOINTS:\n------------\nA : free\nB : free\nC : free\nD : dependent by (1)\n\nHYPOTHESIS:\n------------\n(1) ABCD parallelogram\n\n\njulia> th = @th Segment(A, B) ≅ Segment(C, D)\nTHESIS:\n------------\nAB ≅ CD\n\n\njulia> prove(hp, th)\nAssigned coordinates:\n---------------------\nA = (0, 0)\nB = (u₁, 0)\nC = (u₂, u₃)\nD = (x₁, x₂)\n\nGoal 1: success\n\nNondegeneracy conditions:\n-------------------------\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometricTheoremProver.@hp-Tuple{Any}","page":"API","title":"GeometricTheoremProver.@hp","text":"@hp(block)\n\nmacro to construct the hypothesis of the theorem.\n\nInput\n\nblock – An expression containing the hypothesis of the theorem, can be a single statement          or a sequence of statements between begin...end.\n\nOutput\n\nAn object of type Hypothesis.\n\nExamples\n\njulia> @hp O := Circle(A, B, C)\nPOINTS:\n------------\nA : free\nB : free\nC : free\nO : dependent by (1)\n\nHYPOTHESIS:\n------------\n(1) OA ≅ OB ≅ OC\n\n\n\n\n\n","category":"macro"},{"location":"api/#GeometricTheoremProver.@th-Tuple{Any}","page":"API","title":"GeometricTheoremProver.@th","text":"@th(block)\n\nmacro to construct the thesis of the theorem.\n\nInput\n\nblock – An expression containing the thesis of the theorem, can be a single statement          or a sequence of statements between begin...end.\n\nOutput\n\nAn object of type Thesis.\n\nExamples\n\njulia> @th Segment(A, O) ≅ Segment(O, C)\nTHESIS:\n------------\nAO ≅ OC\n\n\n\n\n\n","category":"macro"},{"location":"language/#Language-specifications","page":"Language specification","title":"Language specifications","text":"","category":"section"},{"location":"language/","page":"Language specification","title":"Language specification","text":"This document lists the statements allowed in the GeometricTheoremProver DSL, describing whether they introduce new points and if they are free, semifree, or dependent","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"Statement New points Constraints\npoints(PP...) points in PP free none\nP := P ∈ Segment(A, B) A B free, P semifree P ∈ AB\nD := Segment(A, B) ⟂ Segment(C, D) A B C free, D semifree AB ⟂ CD\nD := Segment(A, B) ∥ Segment(C, D) A B C free, D semifree AB ∥ CD\nD := Segment(A, B) ≅ Segment(C, D) A B C free, D semifree AB ≅ CD\nD := Parallelogram(A, B, C, D) A B C free, D dependent parallelogram(A, B, C, D)\nH := A ↓ Segment(B, C) A B C free, H dependent H ∈ BC, AH ⟂ BC\nM := Midpoint(A, B) A B free, M dependent M = midpoint(A, B)\nM := Segment(A, B) ∩ Segment(C, D) A B C D free, M dependent M ∈ AB, M ∈ CD\nO := Circle(A, B, C) A B C free, O dependent OA ≅ OB ≅ OC\nP := P ∈ Circle(O, A) O A free, P semifree OA ≅ OP","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"If the point already exists and the statement tries to add the point again, the behavior is detemined by the next table","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"Current status New status Outcome\nfree s s\nsemifree free semifree\nsemifree semifree dependent\nsemifree dependent error\ndependent free dependent\ndependent semifree error\ndependent dependent error","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"NOTES:","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"The idea behind the semifree + semifree = dependent rule is to allow to define points by multiple constraints. For example,\nP := Segment(A, B) ⟂ Segment(A, P)\ncreates a point P constrained to lie on the line perpendicular to AB and passing through A. There are infinitely many candidates, but not all points in the plane are good candidates, hence the point is semifree. Adding the constraint\nP := Segment(A, B) ≅ Segment(A, P)\nfurther constraints the point to have distance from A equal to AB. As there are not infinitely many candidates, the point is dependent.\nThe semifree + semifree = dependent does not check for possibly contradicting statements, for example if you type\nA := Segment(A, B) ⟂ Segment(C, D)\nA := Segment(A, B) ∥  Segment(C, D)\nit cannot notice that the two statements are contradicting.","category":"page"},{"location":"write_statements/#First-Theorem","page":"Tutorial","title":"First Theorem","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"This is a beginner tutorial to GeometricTheoremProver.jl. To follow along, you need to install the package with","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"using Pkg; Pkg.add(\"GeometricTheoremProver\")","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Then you can import the package with","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"using GeometricTheoremProver","category":"page"},{"location":"write_statements/#Introduction","page":"Tutorial","title":"Introduction","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Generally speaking, a theorem is composed by two parts: a hypothesis, that is a set of statements assumed to hold and a thesis, that is a set of statements to be derived from the hypothesis and the axioms of the theory we are working in.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Theorems in Euclidean geometry involve geometric entities such as points, lines, circles etc. The hypothesis of the theorem can also be thought as a set of constraints on the points. This can be seen as a set of constructions steps to draw the figure of the theorem. For example the constraint P ∈ Segment(A, B) can be read as take a point P on the Segment AB, this sets some restrictions on what points in the plane we can choose for P.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"A point can be","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"free: any point in the plane satisfies the statement.\nsemifree: there are infinitely many points satisfying the given statement, but not all points in the plane do. Thinking of the Cartesian plane as model for Euclidean geometry, this means that one coordinate can be freely chosen, but the other is then uniquely determined.\ndependent: There is a finite number of points satisfying the given statement.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"With this interpretation, we say that points are introduced by a series of construction steps. These steps form the hypothesis of the theorem","category":"page"},{"location":"write_statements/#Writing-hypothesis","page":"Tutorial","title":"Writing hypothesis","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The hypothesis is written using the @hp macro. The macro can be followed by a single expression of by a begin ... end block containing multiple expressions.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Free points can be introduced with the points function. For example,","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@hp points(A, B, C)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"As we can see, this introduces the free points A, B, C. Since all points are free, there are no constraints in this case.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The general syntax to write constraint is","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"P := constraint","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"this can be read as Let P so that constraint. As you can see, you need to explicitly specify what point is introduced by the constraint. For example","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@hp P := P ∈ Segment(A, B)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Now the hypothesis shows that P is semifree and constrained by statement number (1). Note also that points A and B are automatically introduced as free, even without calling points(A, B). In general given a statement P := constraint, the package will add P as dependent or semifree (depending on the constraint) and all the other points will be added as free if they don't exist already. Let us see a bigger example","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@hp begin\n    M := Midpoint(A, B)\n    P := Segment(P, M) ⟂ Segment(A, B)\n    P := Segment(P, M) ≅ Segment(A, M)\nend","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"This is basically taking a point P on the perpendicular bisector of AB. Let us now notice a few things","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The midpoint of a segment is uniquely defined, hence the statement M := Midpoint(A, B) introduces M as dependent.\nThe second statement P := Segment(P, M) ⟂ Segment(A, B) takes a point P on the perpendicular bisector of AB. Since the point is not uniquely defined by this statement alone, P would be semifree\nThe next statement, however, P := Segment(P, M) ≅ Segment(A, M) adds an additional constraint on P, after which P is uniquely defined and hence it is displayed as dependent, constrained by equations (1) and (2).","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"If you specify a point as semifree by two distinct constraints, the package \"sums\" the two constraints and marks the point as dependent.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The package also prevents you from adding too many constraints to a point, for example the follow would result in an error.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@hp begin\n  points(A, B, C)\n  M := Midpont(A, B)\n  M := Segment(A, B) ⟂ Segment(C, M)\nend","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"ERROR: LoadError: ArgumentError: Cannot add statement (2) to point already defined as dependent by (1)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The constraints M := Midpoint(A, B) already defined uniquely the point M, any extra constraint will be either redundant or contradictory.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"A list of all allowed constraints and a full description of the \"point status algebra\" can be found here.","category":"page"},{"location":"write_statements/#Writing-Thesis","page":"Tutorial","title":"Writing Thesis","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"A thesis is created with the @th macro, followed by a single expression or a begin ... end block. The same constraint syntax used in the hypothesis applies for the thesis, except that now we don't have the P := part, as the thesis does not introduce new points. A couple of examples","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@th Segment(A, B) ⟂ Segment(C, D)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@th begin\n    Segment(A, O) ≅ Segment(O, C)\n    Segment(B, O) ≅ Segment(O, D)\nend","category":"page"},{"location":"write_statements/#Proving-the-theorem","page":"Tutorial","title":"Proving the theorem","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"After you have written the hypothesis and thesis, you can prove the theorem with the prove function. At the moment, only simple Ritt-Wu method is supported. As an example, let us see the Apollonius circle theorem. We choose this theorem because it is a nice show-case, as it uses most of the expressions allowed in the package","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"hp = @hp begin\n        points(A, B, C)\n        C  := Segment(A, B) ⟂ Segment(A, C)\n        M₁ := Midpoint(A, B)\n        M₂ := Midpoint(A, C)\n        M₃ := Midpoint(B, C)\n        H  := A ↓ Segment(B, C) # H is the projection of A to the segment BC\n        O  := Circle(M₁, M₂, M₃)\n    end","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"th = @th H ∈ circle(O, M₁)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"p = prove(hp, th)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Ritt-Wu method is an algebraic method, which means that it first assigns some coordinates to the points and then translates the statements to polynomial equations. Free coordinates are denoted by the letter u and dependent coordinates by x.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Proving the theorem now \"simply\" means doing some operations on the polynomials. Since the proof is a bunch of calculations, it is generally not that interesting to read, hence by default it is only displayed whether the thesis could be successfully proved or not.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The proof also shows the non-degeneracy conditions. When we construct a triangle with vertices, A B C we are generally interested in \"proper triangles\", that is the three vertices are distinct and not on the same line. Otherwise we say we have a degenerate case, in which case the theorem may not hold. However, we are generally interested only in the non-degenerate case and hence the algorithm also computes some extra hypotheses called degeneracy conditions needed for the theorem to hold. If a theorem holds under some non-degeneracy conditions, we say that the thesis follows generally from the hypothesis. If the thesis always follows from the hypothesis, even in possible degenerate cases, we say that the thesis follows strictly from the hypothesis.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"As an illustrative example, let us look closer at the obtained conditis","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"u_1 neq 0\nRecalling that A is at the origin and B had coordinates (u_1 0), the condition is equivalent to A nequiv B.\n-u_1^2+2u_1x_1-u_2^2-x_1^2neq 0\nWith a small rewriting the corresponding degeneracy condition is (u_1-x_1)^2+u_2^2=0, since we are working with real variables this is equivalent to u_1 = x_1 land u_2=0 whence the coordinates of C become (u_1 0), which are the same of B. Hence the non-degeneracy condition is equivalent to B nequiv C.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"In general, figuring out the geometrical interpretation of the algebraic non-degeneracy conditions can be pretty challenging.","category":"page"},{"location":"#GeometricTheoremProver","page":"Home","title":"GeometricTheoremProver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: license: MIT)(Image: CI)(Image: codecov)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package that can prove theorems in Euclidean geometry. Currently, it supports only Ritt-Wu method. For a brief overview check this video at JuliaCon2022.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"GeometricTheoremProver\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"then import the package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GeometricTheoremProver","category":"page"},{"location":"","page":"Home","title":"Home","text":"now you are ready to go. ","category":"page"},{"location":"#Quickstart-Example","page":"Home","title":"Quickstart Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let us prove that Apollonius circle theorem. First we state hypothesis and thesis","category":"page"},{"location":"","page":"Home","title":"Home","text":"hp = @hp begin\n    points(A, B, C)\n    C := Segment(A, B) ⟂ Segment(A, C)\n    M₁ := Midpoint(A, B)\n    M₂ := Midpoint(A, C)\n    M₃ := Midpoint(B, C)\n    H := A ↓ Segment(B, C)\n    O := Circle(M₁, M₂, M₃)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"POINTS:\n------------\nA : free\nB : free\nC : semifree by (1)\nM₁ : dependent by (2)\nM₂ : dependent by (3)\nM₃ : dependent by (4)\nH : dependent by (5)\nO : dependent by (6)\n\nHYPOTHESIS:\n------------\n(1) AB ⟂ AC\n(2) M₁ ∈ AB ∧ AM₁ ≅ M₁B\n(3) M₂ ∈ AC ∧ AM₂ ≅ M₂C\n(4) M₃ ∈ BC ∧ BM₃ ≅ M₃C\n(5) H ∈ BC ∧ AH ⟂ BC\n(6) OM₁ ≅ OM₂ ≅ OM₃","category":"page"},{"location":"","page":"Home","title":"Home","text":"th = @th H ∈ Circle(O, M₁)","category":"page"},{"location":"","page":"Home","title":"Home","text":"THESIS:\n------------\nOH ≅ OM₁","category":"page"},{"location":"","page":"Home","title":"Home","text":"now the theorem can be proved with the prove function","category":"page"},{"location":"","page":"Home","title":"Home","text":"prove(hp, th)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assigned coordinates:\n---------------------\nA = (0, 0)\nB = (u₁, 0)\nC = (x₁, u₂)\nM₁ = (x₂, x₃)\nM₂ = (x₄, x₅)\nM₃ = (x₆, x₇)\nH = (x₈, x₉)\nO = (x₁₀, x₁₁)\n\nGoal 1: success\n\nNondegeneracy conditions:\n-------------------------\nu₁ ≠ 0\n-u₁² + 2u₁x₁ - u₂² - x₁² ≠ 0\nu₂ ≠ 0\n4x₂x₅ - 4x₂x₇ - 4x₃x₄ + 4x₃x₆ + 4x₄x₇ - 4x₅x₆ ≠ 0\n-2x₃ + 2x₇ ≠ 0","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you spot something strange (something doesn't work or doesn't behave as expected), please open a bug issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If have an improvement idea (a new feature, a new piece of documentation, an improvement of an existing feature), you can open an enhancement issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you feel like your issue does not fit any of the above mentioned templates (e.g. you just want to ask something), you can also open a blank issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pull requests are also very welcome! For small fixes, feel free to open a PR directly. For bigger changes, it might be wise to open an issue first.","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Author: Luca Ferranti\nLicense: MIT","category":"page"}]
}
