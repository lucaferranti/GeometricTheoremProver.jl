var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = GeometricTheoremProver","category":"page"},{"location":"api/#GeometricTheoremProver","page":"API","title":"GeometricTheoremProver","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for GeometricTheoremProver.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GeometricTheoremProver]","category":"page"},{"location":"api/#GeometricTheoremProver.prove-Tuple{GeometricTheoremProver.Hypothesis, GeometricTheoremProver.Thesis}","page":"API","title":"GeometricTheoremProver.prove","text":"prove(hp::Hypothesis, th::Thesis[, method=RittWuMethod])\nprove(theorem::Theorem[, method=RittWuMethod])\n\nProves a thereom with given hypothesis hp and thesis th.\n\nInput\n\nhp::Hypothesis                  – hypothesis of the theorem\nth::Thesis                      – thesis of the theorem\nmethod<:AbstractGeometricProver – method to prove the theorem, default RittWuMethod.\n\nAlternatively, instead of passing hypothesis and thesis as two distinct parameters, it is possible to pass them together as a Theorem object.\n\nOutput\n\nA proof of the the theorem. The type of the output depends on the chosen method\n\nAlgorithms\n\nCurrently the following provers are supported\n\nRittWuMethod\n\nExamples\n\njulia> hp = @hp D := Parallelogram(A, B, C, D)\nPOINTS:\n------------\nA : free\nB : free\nC : free\nD : dependent by (1)\n\nHYPOTHESIS:\n------------\n(1) ABCD parallelogram\n\n\njulia> th = @th Segment(A, B) ≅ Segment(C, D)\nTHESIS:\n------------\nAB ≅ CD\n\n\njulia> prove(hp, th)\nAssigned coordinates:\n---------------------\nA = (0, 0)\nB = (u₁, 0)\nC = (u₂, u₃)\nD = (x₁, x₂)\n\nGoal 1: success\n\nNondegeneracy conditions:\n-------------------------\n\n\n\n\n\n","category":"method"},{"location":"api/#GeometricTheoremProver.@hp-Tuple{Any}","page":"API","title":"GeometricTheoremProver.@hp","text":"@hp(block)\n\nmacro to construct the hypothesis of the theorem.\n\nInput\n\nblock – An expression containing the hypothesis of the theorem, can be a single statement          or a sequence of statements between begin...end.\n\nOutput\n\nAn object of type Hypothesis.\n\nExamples\n\njulia> @hp O := Circle(A, B, C)\nPOINTS:\n------------\nA : free\nB : free\nC : free\nO : dependent by (1)\n\nHYPOTHESIS:\n------------\n(1) OA ≅ OB ≅ OC\n\n\n\n\n\n","category":"macro"},{"location":"api/#GeometricTheoremProver.@th-Tuple{Any}","page":"API","title":"GeometricTheoremProver.@th","text":"@th(block)\n\nmacro to construct the thesis of the theorem.\n\nInput\n\nblock – An expression containing the thesis of the theorem, can be a single statement          or a sequence of statements between begin...end.\n\nOutput\n\nAn object of type Thesis.\n\nExamples\n\njulia> @th Segment(A, O) ≅ Segment(O, C)\nTHESIS:\n------------\nAO ≅ OC\n\n\n\n\n\n","category":"macro"},{"location":"language/#Language-specifications","page":"Language specification","title":"Language specifications","text":"","category":"section"},{"location":"language/","page":"Language specification","title":"Language specification","text":"This document lists the statements allowed in the GeometricTheoremProver DSL, describing whether they introduce new points and if they are free, semifree, or dependent","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"Statement New points Constraints\npoints(PP...) points in PP free none\nP := P ∈ Segment(A, B) A B free, P semifree P ∈ AB\nD := Segment(A, B) ⟂ Segment(C, D) A B C free, D semifree AB ⟂ CD\nD := Segment(A, B) ∥ Segment(C, D) A B C free, D semifree AB ∥ CD\nD := Segment(A, B) ≅ Segment(C, D) A B C free, D semifree AB ≅ CD\nD := Parallelogram(A, B, C, D) A B C free, D dependent parallelogram(A, B, C, D)\nH := A ↓ Segment(B, C) A B C free, H dependent H ∈ BC, AH ⟂ BC\nM := Midpoint(A, B) A B free, M dependent M = midpoint(A, B)\nM := Segment(A, B) ∩ Segment(C, D) A B C D free, M dependent M ∈ AB, M ∈ CD\nO := Circle(A, B, C) A B C free, O dependent OA ≅ OB ≅ OC\nP := P ∈ Circle(O, A) O A free, P semifree OA ≅ OP","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"If the point already exists and the statement tries to add the point again, the behavior is detemined by the next table","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"Current status New status Outcome\nfree s s\nsemifree free semifree\nsemifree semifree dependent\nsemifree dependent error\ndependent free dependent\ndependent semifree error\ndependent dependent error","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"NOTES:","category":"page"},{"location":"language/","page":"Language specification","title":"Language specification","text":"The idea behind the semifree + semifree = dependent rule is to allow to define points by multiple constraints. For example,\nP := Segment(A, B) ⟂ Segment(A, P)\ncreates a point P constrained to lie on the line perpendicular to AB and passing through A. There are infinitely many candidates, but not all points in the plane are good candidates, hence the point is semifree. Adding the constraint\nP := Segment(A, B) ≅ Segment(A, P)\nfurther constraints the point to have distance from A equal to AB. As there are not infinitely many candidates, the point is dependent.\nThe semifree + semifree = dependent does not check for possibly contradicting statements, for example if you type\nA := Segment(A, B) ⟂ Segment(C, D)\nA := Segment(A, B) ∥  Segment(C, D)\nit cannot notice that the two statements are contradicting.","category":"page"},{"location":"CONTRIBUTING/#GeometricTheoremProver.jl-contribution-guidelines","page":"Contributing","title":"GeometricTheoremProver.jl contribution guidelines","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"First of all, huge thanks for your interest in the package! ✨","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"This page has some hopefully useful guidelines. If this is your first time contributing, please read the pull request-workflow section, mainly to make sure everything works smoothly and you don't get stuck with some nasty technicalities. ","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"You are also encouraged to read the coding and documentation guidelines, but you don't need to deeply study and memorize those. Core developers are here to help you. Most importantly, relax and have fun!","category":"page"},{"location":"CONTRIBUTING/#Opening-issues","page":"Contributing","title":"Opening issues","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you spot something strange (something doesn't work or doesn't behave as expected), please open a bug issue.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If have an improvement idea (a new feature, a new piece of documentation, an enhancement of an existing feature), you can open a feature request issue.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"In both cases, try to follow the template, but do not worry if you don't know how to fill something. ","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you feel like your issue does not fit any of the above mentioned templates (e.g. you just want to ask something), you can also open a blank issue.","category":"page"},{"location":"CONTRIBUTING/#Pull-request-workflow","page":"Contributing","title":"Pull request workflow","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Pull requests are also warmly welcome. For small fixes/additions, feel free to directly open a PR. For bigger more ambitious PRs, it is preferable to open an issue first to discuss it. As a rule of thumb, every pull request should be as atomic as possible (fix one bug, add one feature, address one issue).","category":"page"},{"location":"CONTRIBUTING/#Setup","page":"Contributing","title":"Setup","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"note: Note\nThis is just one way, you can do differently (e.g. clone your fork and add the original repo as upstream). In that case, make sure to use the correct remote names","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"This is something that needs to be done only once, the first time you start contributing","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"1. From the Julia REPL in package mode (you can enter package mode by typing ]) do","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"pkg> dev GeometricTheoremProver","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"this will clone the repository into .julia/dev/GeometricTheoremProver. When you dev the package, Julia will use the code in the dev folder instead of the official released one. If you want to go back to use the released version, you can do free GeometricTheoremProver.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"2. Fork the repository.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"3. Navigate to .julia/dev/GeometricTheoremProver where you cloned the original repository before. Now you need to add your fork as remote. This can be done with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git remote add $your_remote_name $your_fork_url","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"your_remote_name can be whatever you want. your_fork_url is the url you would use to clone your fork repository. For example if your github username is johndoe and you want to call the remote jd then the previous command would be","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git remote add jd https://github.com/johndoe/GeometricTheoremProver.jl.git","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"you can verify that you have the correct remotes with git remote -v the output should be similar to","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"jd        https://github.com/johndoe/GeometricTheoremProver.jl.git (fetch)\njd        https://github.com/johndoe/GeometricTheoremProver.jl.git (push)\norigin    https://github.com/lucaferranti/GeometricTheoremProver.jl.git (fetch)\norigin    https://github.com/lucaferranti/GeometricTheoremProver.jl.git (push)","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Now everything is set!","category":"page"},{"location":"CONTRIBUTING/#Contribution-workflow","page":"Contributing","title":"Contribution workflow","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"0. Navigate to .julia/dev/GeometricTheoremProver and make sure you are on the main branch. You can check with git branch and if needed use git switch main to switch to the main branch. The next steps assume you are in the GeometricTheoremProver folder.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"1. Before you start modifying, it's good to make sure that your local main branch is synchronized with the main branch in the package repo. To do so, run","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git fetch origin\ngit merge origin/main","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Since you should never directly modify the main branch locally, this should not cause any conflicts. If you didn't follow the previous setup instructions, you may need to change origin with the appropriate remote name.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"2. Now create a new branch for the new feature you want to develop. If possible, the branch should start with your name/initials and have a short but descriptive name of what you are doing (no strict rules). For example, if I (John Doe) want to fix the code that parses a perpendicularity statement, I would call the branch jd-parse-perp or something like that. You can create a new branch and switch to it with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git switch -c jd-parse-perp","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you are targetting a specific issue, you can also name the branch after the issue number, e.g. jd-42.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"3. Now let the fun begin! Fix bugs, add the new features, modify the docs, whatever you do, it's gonna be awesome! Check also the coding guidelines and documentation guidelines. Do not worry if it feels like a lot of rules, the core developers are here to help and guide.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"4. It is important to run the tests of the package locally, to check that you haven't accidentally broken anything. You can run the tests with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"julia --project test/runtests.jl","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you have changed the documentation, you can build it locally with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"julia --project=docs docs/make.jl","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"This will build the docs in the docs/build folder, you can open docs/build/index.html and check that everything looks nice. Check also in the terminal that you don't have error messages (no broken links, doctests pass).","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"5. When you are ready, commit your changes. If example you want to commit src/file1.jl, src/file2.jl","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git add src/file1.jl src/file2.jl\ngit commit -m \"short description of what you did\"","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"You can also add and commit all changes at once with","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git commit -a -m \"short description of what you did\"","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"finally you are ready to push to your fork. If your fork remote is called jd and your branch is called jd-parse-perp, do","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"git push -u jd jd-parse-perp","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"The -u flag sets the upstream, so next time you want to push to the same branch you can just do git push.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"6. Next, go to the package repository, you should see a message inviting you to open a pull request, do it! Make sure you are opening the PR to origin/main. Try to fill the blanks in the pull request template, but do not worry if you don't know anything. Also, your work needs not be polished and perfect to open the pull request! You are also very welcome to open it as a draft and request feedback, assistance, etc.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"7. If nothing happens within 7 working days, feel free to ping Luca Ferranti (@lucaferranti) every 1-2 days until you get his attention.","category":"page"},{"location":"CONTRIBUTING/#Coding-guideline","page":"Contributing","title":"Coding guideline","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Try to roughly follow the bluestyle style guideline.\nIf you add new functionalities, they should also be tested. Exported functions should also have a docstring.\nThe test folder should roughly follow the structure of the src folder. That is if you create src/file1.jl there should also be test/test_file1.jl. There can be exceptions, the main point being that both test and src should have a logical structure and should be easy to find the tests for a given function.\nThe runtests.jl should have only inlcude statements.","category":"page"},{"location":"CONTRIBUTING/#Add-dependency","page":"Contributing","title":"Add dependency","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If the function you are adding needs an external package (say Example.jl), this should be added as dependency, to do so","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Go to GeometricTheoremProver.jl and start a Julia session and activate the current environment with julia --project\nEnter the package mode (press ]) and add the package you want to add, e.g ]add Example.\nYou can verify that the package was added by typing st while in package mode. You can exit the package mode by pressing backspace\nOpen the Project.toml file, your package should now be listed in the [deps] section.\nIn the [compat] section, specify the compatibility requirements. Packages are listed alphabetically. More details about specifying compatibility can be found here\nIn the GeometricTheoremProver.jl file, add the line using Example together with the other using statements, or import Example: fun1, fun2 if you are planning to extend those functions.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If the dependency is quite heavy and used only by some functionalities, you may consider adding that as optional dependency. To do so,","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Repeat the steps 1-5 above\nIn the [deps] section of Project.toml locate the package you want to make an optional dependency and move the corresponding line to [extras], keep alphabetical ordering.\nAdd the dependency name to the test entry in the [targets] section\nIn the GeometricTheoremProver.jl file, locate the __init__ function and add the line","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"@require \"\"\"Example = \"7876af07-990d-54b4-ab0e-23690620f79a\" include(\"file.jl\")\"\"\"","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"where file.jl is the file containing the functions needing Example.jl. The line Example = \"7876af07-990d-54b4-ab0e-23690620f79a\" is the same in the Project.toml","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"In file.jl the first line should be using .Example (or import .Example: fun1, fun2), note the dot before the package name. Then write the functions in the file normally","category":"page"},{"location":"CONTRIBUTING/#Documentation-guideline","page":"Contributing","title":"Documentation guideline","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Documentation is written with Documenter.jl. Documentation files are in docs/src, generally as markdown file.\nIf you want to modify an existing file, open it and start writing. If you want to add a new page, create a new markdown file in the appropriate subfolder of docs/src and add the line \"mytitle\" => \"path/to/file.md\" to the page structure in the docs/make.jl file here. \nIf you want to include a Julia code example that is not executed in the markdown file, use ```julia blocks, e.g.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```julia\na = 1\nb = 2\n```","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Julia code that is executed should use ```@example blocks, e.g.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```@example\na = 1\nb = 2\n```","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you want to reuse variables between @example blocks, they should be named, for example","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```@example filename\na = 1\nb = 2\n```\n\n... some text ...\n\n```@example filename\nc = a + b\n```","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If you want to run a Julia code block but don't want the output to be displayed, add nothing # hide as last line of the code block.\nYou can plot and include figures as follows","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```@example\n# code for plotting\nsavefig(\"figname.png\") # hide\n```\n\n![][figname.png]","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Use single ticks for inline code `A` and double ticks for maths ``A``. For single line equations, use \nFor single-line equations, use ```math blocks, e.g.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"```math\n|A_cx-b_c| \\le A_\\Delta|x| + b_\\Delta,\n```","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"You can refer to functions in the pacakge with [`func_name`](@ref)\nYou can quote references with [[REF01]](@ref)\nIf you want to add references, you can use the following template","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"#### [REF01] \n\n```@raw html\n<ul><li>\n```\nAuthor(s), [*Paper name in italic*](link_to_pdf_if_available), other infos (publisher, year, etc.)\n```@raw html\n<li style=\"list-style: none\"><details>\n<summary>bibtex</summary>\n```\n```\nINSERT BIBTEX HERE\n```\n```@raw html\n</details></li></ul>\n```\n---","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"If the pdf of the paper is freely (and legally!) available online, make the title of the paper a link to it.\nThe reference code should be first 3 letters of first author surname + last two digits of year, e.g [FER87]. To disambiguate duplicates, use letter, e.g. [FER87a], [FER87b].","category":"page"},{"location":"CONTRIBUTING/#Docstrings","page":"Contributing","title":"Docstrings","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Each exported function should have a docstring. The docstring should roughly follow the following structure","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"\"\"\"\n    funname(param1, param2[, optional_param])\n\nA short description (1-2 lines) of what the function does\n\n### Input\n\nLis of inputs. Not needed if clear from description and signature.\n\n### Output\n\nList of outputs. Not needed if clear from description and signature.\n\n### Notes\n\nAnything else which is important.\n\n### Algorithm\n\nWhat algorithms the function uses, preferably with references.\n\n### Example\n\nAt least one example, formatted as julia REPL, of what the function does.\nPreferably, as a doctest.\n\"\"\"","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Optional parameters in the function signature go around brackets.\nList of inputs and outputs can be omitted if the function has few parameters and they are already clearly explained by the function signature and description.\nExamples should be doctests. Exceptions to this can occur if e.g. the function is not deterministic (random initialization) or requires a heavy optional dependency.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Here is an example","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"\"\"\"\n    something(A::Matrix{T}, b::Vector{T}[, tol=1e-10]) where {T<:Real}\n\nthis function computes the somethig product between the matrix ``A`` and vector ``b``.\n\n### Input\n\n- `A`   -- ``n × n`` matrix representing the left-something of the system\n- `b`   -- vector of length ``n``, representing the right-something of the system\n- `tol` -- (optional), tolerance to compute the something product, default 1e-10\n\n### Output\n\nA vector of length ``n`` representing the something product.\n\n### Notes\n\nIf `A` and `b` are complex, use the [`somethingelse`](@ref) function instead.\n\n### Algorithm\n\nThe function uses the *Lost Numbers* algorithm proposed by Hugo Reyes in [[REY42]](@ref).\n\n### Example\n\n```jldoctest\njulia> A = [4 8;15 16]\n2×2 Matrix{Int64}:\n  4   8\n 15  16\n\njulia> b = [23, 42]\n2-element Vector{Int64}:\n 23\n 42\n\njulia> something(A, b)\n2-element Vector{Int64}:\n 108\n 108\n```\n\"\"\"","category":"page"},{"location":"CONTRIBUTING/#Acknowledgments","page":"Contributing","title":"Acknowledgments","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Here is a list of useful resources from which this guideline was inspired","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"JuliaReach developers docs\nMaking a first Julia pull request\nColPrac\nJulia contributing guideline","category":"page"},{"location":"write_statements/#First-Theorem","page":"Tutorial","title":"First Theorem","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"This is a beginner tutorial to GeometricTheoremProver.jl. To follow along, you need to install the package with","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"using Pkg; Pkg.add(\"GeometricTheoremProver\")","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Then you can import the package with","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"using GeometricTheoremProver","category":"page"},{"location":"write_statements/#Introduction","page":"Tutorial","title":"Introduction","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Generally speaking, a theorem is composed by two parts: a hypothesis, that is a set of statements assumed to hold and a thesis, that is a set of statements to be derived from the hypothesis and the axioms of the theory we are working in.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Theorems in Euclidean geometry involve geometric entities such as points, lines, circles etc. The hypothesis of the theorem can also be thought as a set of constraints on the points. This can be seen as a set of constructions steps to draw the figure of the theorem. For example the constraint P ∈ Segment(A, B) can be read as take a point P on the Segment AB, this sets some restrictions on what points in the plane we can choose for P.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"A point can be","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"free: any point in the plane satisfies the statement.\nsemifree: there are infinitely many points satisfying the given statement, but not all points in the plane do. Thinking of the Cartesian plane as model for Euclidean geometry, this means that one coordinate can be freely chosen, but the other is then uniquely determined.\ndependent: There is a finite number of points satisfying the given statement.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"With this interpretation, we say that points are introduced by a series of construction steps. These steps form the hypothesis of the theorem","category":"page"},{"location":"write_statements/#Writing-hypothesis","page":"Tutorial","title":"Writing hypothesis","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The hypothesis is written using the @hp macro. The macro can be followed by a single expression of by a begin ... end block containing multiple expressions.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Free points can be introduced with the points function. For example,","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@hp points(A, B, C)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"As we can see, this introduces the free points A, B, C. Since all points are free, there are no constraints in this case.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The general syntax to write constraint is","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"P := constraint","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"this can be read as Let P so that constraint. As you can see, you need to explicitly specify what point is introduced by the constraint. For example","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@hp P := P ∈ Segment(A, B)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Now the hypothesis shows that P is semifree and constrained by statement number (1). Note also that points A and B are automatically introduced as free, even without calling points(A, B). In general given a statement P := constraint, the package will add P as dependent or semifree (depending on the constraint) and all the other points will be added as free if they don't exist already. Let us see a bigger example","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@hp begin\n    M := Midpoint(A, B)\n    P := Segment(P, M) ⟂ Segment(A, B)\n    P := Segment(P, M) ≅ Segment(A, M)\nend","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"This is basically taking a point P on the perpendicular bisector of AB. Let us now notice a few things","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The midpoint of a segment is uniquely defined, hence the statement M := Midpoint(A, B) introduces M as dependent.\nThe second statement P := Segment(P, M) ⟂ Segment(A, B) takes a point P on the perpendicular bisector of AB. Since the point is not uniquely defined by this statement alone, P would be semifree\nThe next statement, however, P := Segment(P, M) ≅ Segment(A, M) adds an additional constraint on P, after which P is uniquely defined and hence it is displayed as dependent, constrained by equations (1) and (2).","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"If you specify a point as semifree by two distinct constraints, the package \"sums\" the two constraints and marks the point as dependent.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The package also prevents you from adding too many constraints to a point, for example the follow would result in an error.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@hp begin\n  points(A, B, C)\n  M := Midpont(A, B)\n  M := Segment(A, B) ⟂ Segment(C, M)\nend","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"ERROR: LoadError: ArgumentError: Cannot add statement (2) to point already defined as dependent by (1)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The constraints M := Midpoint(A, B) already defined uniquely the point M, any extra constraint will be either redundant or contradictory.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"A list of all allowed constraints and a full description of the \"point status algebra\" can be found here.","category":"page"},{"location":"write_statements/#Writing-Thesis","page":"Tutorial","title":"Writing Thesis","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"A thesis is created with the @th macro, followed by a single expression or a begin ... end block. The same constraint syntax used in the hypothesis applies for the thesis, except that now we don't have the P := part, as the thesis does not introduce new points. A couple of examples","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@th Segment(A, B) ⟂ Segment(C, D)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"@th begin\n    Segment(A, O) ≅ Segment(O, C)\n    Segment(B, O) ≅ Segment(O, D)\nend","category":"page"},{"location":"write_statements/#Proving-the-theorem","page":"Tutorial","title":"Proving the theorem","text":"","category":"section"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"After you have written the hypothesis and thesis, you can prove the theorem with the prove function. At the moment, only simple Ritt-Wu method is supported. As an example, let us see the Apollonius circle theorem. We choose this theorem because it is a nice show-case, as it uses most of the expressions allowed in the package","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"hp = @hp begin\n        points(A, B, C)\n        C  := Segment(A, B) ⟂ Segment(A, C)\n        M₁ := Midpoint(A, B)\n        M₂ := Midpoint(A, C)\n        M₃ := Midpoint(B, C)\n        H  := A ↓ Segment(B, C) # H is the projection of A to the segment BC\n        O  := Circle(M₁, M₂, M₃)\n    end","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"th = @th H ∈ circle(O, M₁)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"p = prove(hp, th)","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Ritt-Wu method is an algebraic method, which means that it first assigns some coordinates to the points and then translates the statements to polynomial equations. Free coordinates are denoted by the letter u and dependent coordinates by x.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"Proving the theorem now \"simply\" means doing some operations on the polynomials. Since the proof is a bunch of calculations, it is generally not that interesting to read, hence by default it is only displayed whether the thesis could be successfully proved or not.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"The proof also shows the non-degeneracy conditions. When we construct a triangle with vertices, A B C we are generally interested in \"proper triangles\", that is the three vertices are distinct and not on the same line. Otherwise we say we have a degenerate case, in which case the theorem may not hold. However, we are generally interested only in the non-degenerate case and hence the algorithm also computes some extra hypotheses called degeneracy conditions needed for the theorem to hold. If a theorem holds under some non-degeneracy conditions, we say that the thesis follows generally from the hypothesis. If the thesis always follows from the hypothesis, even in possible degenerate cases, we say that the thesis follows strictly from the hypothesis.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"As an illustrative example, let us look closer at the obtained conditis","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"u_1 neq 0\nRecalling that A is at the origin and B had coordinates (u_1 0), the condition is equivalent to A nequiv B.\n-u_1^2+2u_1x_1-u_2^2-x_1^2neq 0\nWith a small rewriting the corresponding degeneracy condition is (u_1-x_1)^2+u_2^2=0, since we are working with real variables this is equivalent to u_1 = x_1 land u_2=0 whence the coordinates of C become (u_1 0), which are the same of B. Hence the non-degeneracy condition is equivalent to B notequiv  C.","category":"page"},{"location":"write_statements/","page":"Tutorial","title":"Tutorial","text":"In general, figuring out the geometrical interpretation of the algebraic non-degeneracy conditions can be pretty challenging.","category":"page"},{"location":"#GeometricTheoremProver.jl","page":"Home","title":"GeometricTheoremProver.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: license: MIT)(Image: CI)(Image: codecov)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package that can prove theorems in Euclidean geometry. Currently, it supports only Ritt-Wu method. For a brief overview check this video at JuliaCon2022.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"GeometricTheoremProver\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"then import the package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GeometricTheoremProver","category":"page"},{"location":"","page":"Home","title":"Home","text":"now you are ready to go. ","category":"page"},{"location":"#Quickstart-Example","page":"Home","title":"Quickstart Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let us prove that Apollonius circle theorem. First we state hypothesis and thesis","category":"page"},{"location":"","page":"Home","title":"Home","text":"hp = @hp begin\n    points(A, B, C)\n    C := Segment(A, B) ⟂ Segment(A, C)\n    M₁ := Midpoint(A, B)\n    M₂ := Midpoint(A, C)\n    M₃ := Midpoint(B, C)\n    H := A ↓ Segment(B, C)\n    O := Circle(M₁, M₂, M₃)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"POINTS:\n------------\nA : free\nB : free\nC : semifree by (1)\nM₁ : dependent by (2)\nM₂ : dependent by (3)\nM₃ : dependent by (4)\nH : dependent by (5)\nO : dependent by (6)\n\nHYPOTHESIS:\n------------\n(1) AB ⟂ AC\n(2) M₁ ∈ AB ∧ AM₁ ≅ M₁B\n(3) M₂ ∈ AC ∧ AM₂ ≅ M₂C\n(4) M₃ ∈ BC ∧ BM₃ ≅ M₃C\n(5) H ∈ BC ∧ AH ⟂ BC\n(6) OM₁ ≅ OM₂ ≅ OM₃","category":"page"},{"location":"","page":"Home","title":"Home","text":"th = @th H ∈ Circle(O, M₁)","category":"page"},{"location":"","page":"Home","title":"Home","text":"THESIS:\n------------\nOH ≅ OM₁","category":"page"},{"location":"","page":"Home","title":"Home","text":"now the theorem can be proved with the prove function","category":"page"},{"location":"","page":"Home","title":"Home","text":"prove(hp, th)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assigned coordinates:\n---------------------\nA = (0, 0)\nB = (u₁, 0)\nC = (x₁, u₂)\nM₁ = (x₂, x₃)\nM₂ = (x₄, x₅)\nM₃ = (x₆, x₇)\nH = (x₈, x₉)\nO = (x₁₀, x₁₁)\n\nGoal 1: success\n\nNondegeneracy conditions:\n-------------------------\nu₁ ≠ 0\n-u₁² + 2u₁x₁ - u₂² - x₁² ≠ 0\nu₂ ≠ 0\n4x₂x₅ - 4x₂x₇ - 4x₃x₄ + 4x₃x₆ + 4x₄x₇ - 4x₅x₆ ≠ 0\n-2x₃ + 2x₇ ≠ 0","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you spot something strange (something doesn't work or doesn't behave as expected), please open a bug issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If have an improvement idea (a new feature, a new piece of documentation, an enhancement of an existing feature), you can open a feature request issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you feel like your issue does not fit any of the above mentioned templates (e.g. you just want to ask something), you can also open a blank issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pull requests are also very welcome! For small fixes, feel free to open a PR directly. For bigger changes, it might be wise to open an issue first. Also, make sure to checkout the contributing guidelines.","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Author: Luca Ferranti\nLicense: MIT","category":"page"}]
}
